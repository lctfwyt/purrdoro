<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ±çŒ«çŒ«ç•ªèŒ„é’ŸğŸ…</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 85 85%22><text x=%2243%22 y=%2230%22 text-anchor=%22middle%22 dominant-baseline=%22central%22 font-size=%2280%22>ğŸ…</text></svg>">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#93c5fd">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="çŒ«çŒ«ç•ªèŒ„é’Ÿ">
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
  <div class="max-w-2xl mx-auto">
    <div class="bg-white rounded-2xl shadow-2xl p-8">
      <!-- æ ‡é¢˜ -->
      <div class="text-center mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">ğŸ±çŒ«çŒ«ç•ªèŒ„é’ŸğŸ…</h1>
        <p class="text-gray-600">æ¸©æŸ”é™ªä½ åº¦è¿‡æ¯ä¸€å¤©</p>
      </div>

      <!-- å¯ç”¨æç¤ºï¼ˆç»Ÿä¸€å…¥å£ï¼‰ -->
      <div id="setup-prompt" class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-xl p-5 mb-6">
        <div class="text-center mb-4">
          <p class="text-gray-700 font-medium mb-3">ğŸ”” å¯ç”¨æé†’åŠŸèƒ½</p>
          <button id="enable-audio-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2.5 px-6 rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg">
            å¼€å¯å£°éŸ³ + é€šçŸ¥
          </button>
        </div>
        <div class="text-xs text-gray-500 space-y-1.5 border-t border-blue-100 pt-3">
          <p class="flex items-center justify-center gap-1">
            <span>ğŸ’¡</span>
            <span>ä¸‹è½½ä¸ºæ¡Œé¢åº”ç”¨æˆ–æ·»åŠ åˆ°æ‰‹æœºä¸»å±å¹•ï¼Œæé†’æ›´å¯é </span>
            <button id="install-btn-inline" class="hidden text-blue-500 hover:text-blue-600 underline ml-1">ç«‹å³å®‰è£…</button>
          </p>
        </div>
      </div>

      <!-- å½“å‰çŠ¶æ€æ˜¾ç¤º -->
      <div id="status-display" class="rounded-xl p-6 text-white mb-6">
        <div class="flex items-center justify-center mb-4">
          <svg id="status-icon" class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"></svg>
        </div>
        <h2 id="status-message" class="text-2xl font-bold text-center mb-2"></h2>
        <div id="timer-display" class="text-center"></div>
      </div>

      <!-- æ¯æ—¥è¿›åº¦ -->
      <div class="mb-6">
        <div class="flex justify-between items-center mb-3">
          <h3 class="text-lg font-semibold text-gray-700">ä»Šæ—¥è¿›åº¦</h3>
          <span id="progress-text" class="text-sm text-gray-600"></span>
        </div>
        <div class="flex gap-4 w-full">
          <div class="flex gap-1 flex-[4]" id="morning-progress"></div>
          <div class="flex gap-1 flex-[4]" id="afternoon-progress"></div>
          <div class="flex gap-1 flex-[2]" id="evening-progress"></div>
        </div>
      </div>

      <!-- æ—¶é—´è¡¨ -->
      <div class="space-y-3" id="schedule-container">
        <h3 class="text-lg font-semibold text-gray-700 mb-3">æ¯æ—¥æ—¶é—´è¡¨</h3>
      </div>

      <!-- GitHub é“¾æ¥ -->
      <div class="mt-8 text-center">
        <a href="https://github.com/lctfwyt/purrdoro" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 text-sm text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          <span>GitHub</span>
        </a>
      </div>
    </div>
  </div>

  <script>
    // ==================== é…ç½® ====================
    const CONFIG = {
      WORK_MINUTES: 25,
      REST_MINUTES: 5,
      PREP_MINUTES: 10
    };

    const SESSIONS = [
      { name: 'ä¸Šåˆç•ªèŒ„ç»„', start: '10:00', end: '12:00', pomodoros: 4 },
      { name: 'ä¸‹åˆç•ªèŒ„ç»„', start: '13:30', end: '15:30', pomodoros: 4 },
      { name: 'å‚æ™šç•ªèŒ„ç»„', start: '15:50', end: '16:50', pomodoros: 2 }
    ];

    // ==================== çŠ¶æ€ ====================
    const state = {
      audioContext: null,
      audioEnabled: false,
      notificationEnabled: false,
      wakeLock: null,
      lastAlertKey: ''
    };

    // ==================== éŸ³é¢‘ç³»ç»Ÿ ====================
    function initAudioContext() {
      if (!state.audioContext) {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return state.audioContext;
    }

    async function ensureAudioContextActive() {
      if (!state.audioContext) initAudioContext();
      if (state.audioContext.state === 'suspended') {
        await state.audioContext.resume().catch(() => {});
      }
    }

    // åå¤‡æç¤ºéŸ³
    function playFallbackBeep() {
      new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQQAAAAAAA==').play().catch(() => {});
    }

    function scheduleBeep(frequency, duration, startTime) {
      if (!state.audioContext) return;

      const oscillator = state.audioContext.createOscillator();
      const gainNode = state.audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(state.audioContext.destination);
      oscillator.frequency.value = frequency;
      oscillator.type = 'sine';

      const stopTime = startTime + (duration / 1000);
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, stopTime);

      oscillator.start(startTime);
      oscillator.stop(stopTime);
    }

    async function playBeepSequence(beeps) {
      await ensureAudioContextActive();

      // å¦‚æœé¡µé¢åœ¨åå°ï¼Œå°è¯•æ’­æ”¾åå¤‡æç¤ºéŸ³
      if (document.visibilityState !== 'visible') {
        playFallbackBeep();
      }

      // Web Audio API å¯èƒ½æ— æ³•åœ¨åå°å·¥ä½œï¼Œä½†ä»å°è¯•æ’­æ”¾
      try {
        const now = state.audioContext.currentTime;
        let currentTime = now + 0.1;

        for (const beep of beeps) {
          const { frequency = 800, duration = 200, count = 1, interval = 350 } = beep;
          for (let i = 0; i < count; i++) {
            scheduleBeep(frequency, duration, currentTime);
            currentTime += (duration + interval) / 1000;
          }
        }
      } catch (e) {
        console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
      }
    }

    // ==================== é€šçŸ¥ç³»ç»Ÿ ====================
    async function requestNotificationPermission() {
      if (!('Notification' in window)) return false;
      if (Notification.permission === 'granted') return state.notificationEnabled = true;
      if (Notification.permission === 'denied') return false;
      const p = await Notification.requestPermission();
      return state.notificationEnabled = p === 'granted';
    }

    async function showNotification(title, body, tag, requireInteraction = true) {
      if (!state.notificationEnabled) return;
      const icon = 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%2270%22 font-size=%2280%22>ğŸ…</text></svg>';

      if (navigator.serviceWorker?.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'SHOW_NOTIFICATION', title, body, tag, requireInteraction });
      } else {
        const n = new Notification(title, { body, icon, tag, requireInteraction });
        setTimeout(() => n.close(), requireInteraction ? 30000 : 5000);
      }
    }

    // Wake Lock
    async function requestWakeLock() {
      if (!('wakeLock' in navigator) || document.visibilityState !== 'visible') return false;
      try {
        state.wakeLock = await navigator.wakeLock.request('screen');
        return true;
      } catch (e) {
        return false;
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && state.audioEnabled) {
        await ensureAudioContextActive();
        if (state.wakeLock?.released) await requestWakeLock();
      }
    });

    // åå°ä¿æŒæ´»è·ƒçš„å¿ƒè·³æœºåˆ¶
    let heartbeatId = null;
    function startHeartbeat() {
      if (heartbeatId) clearInterval(heartbeatId);
      heartbeatId = setInterval(() => {
        // é¡µé¢åœ¨åå°æ—¶ï¼Œåªèƒ½æ’­æ”¾é™éŸ³ä¿æŒéŸ³é¢‘é€šé“ï¼Œä¸èƒ½è¯·æ±‚ Wake Lock
        if (document.visibilityState !== 'visible') {
          playFallbackBeep();
        }
        // Wake Lock åªèƒ½åœ¨é¡µé¢å¯è§æ—¶è¯·æ±‚
      }, 30000); // æ¯30ç§’ä¸€æ¬¡
    }

    // åˆå§‹åŒ–
    async function enableAudio() {
      initAudioContext();
      await ensureAudioContextActive();
      state.audioEnabled = true;
      await requestNotificationPermission();
      await requestWakeLock();
      document.getElementById('setup-prompt')?.remove();
      startHeartbeat();
      await playBeepSequence([{ frequency: 523, duration: 200, count: 2, interval: 200 }]);
      showNotification('ğŸ… ç•ªèŒ„é’Ÿå·²å¯åŠ¨', 'å£°éŸ³å’Œé€šçŸ¥å·²å¯ç”¨', 'welcome', false);
    }

    // å·¥å…·å‡½æ•°
    const parseTime = (timeStr) => {
      const [h, m] = timeStr.split(':').map(Number);
      const d = new Date();
      d.setHours(h, m, 0, 0);
      return d;
    };
    const formatTime = (m, s) => `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;

    // è¿›åº¦æ¡æ¸²æŸ“
    const renderSegmentBar = (segs, elapsed, opts) => segs.map(s => {
      const dur = s.end - s.start;
      const prog = Math.max(0, Math.min(dur, elapsed - s.start));
      const pct = (prog / dur) * 100;
      const done = elapsed >= s.end;
      const active = elapsed >= s.start && elapsed < s.end;
      const w = opts.equalWidth ? 'flex-1' : '';
      const ws = opts.equalWidth ? '' : `style="width:${(dur / opts.totalSeconds) * 100}%"`;
      return `<div class="h-6 rounded-md overflow-hidden border-2 ${opts.borderColor} ${w}" ${ws}><div class="h-full transition-all duration-300" style="width:${done ? 100 : pct}%;background:${done || active ? opts.fillColor : 'transparent'}"></div></div>`;
    }).join('');

    // ==================== çŠ¶æ€è®¡ç®— ====================
    function getCurrentStatus() {
      const now = new Date();

      for (const session of SESSIONS) {
        const sessionStart = parseTime(session.start);
        const sessionEnd = parseTime(session.end);
        const prepTime = new Date(sessionStart.getTime() - CONFIG.PREP_MINUTES * 60 * 1000);

        // å‡†å¤‡æ—¶é—´
        if (now >= prepTime && now < sessionStart) {
          const minutesUntilStart = Math.ceil((sessionStart - now) / 60000);
          return {
            type: 'prep',
            session: session.name,
            message: `${session.name}å°†åœ¨${minutesUntilStart}åˆ†é’Ÿåå¼€å§‹`,
            timeLeft: sessionStart - now
          };
        }

        // åœ¨æ—¶é—´æ®µå†…
        if (now >= sessionStart && now < sessionEnd) {
          const totalDuration = (CONFIG.WORK_MINUTES + CONFIG.REST_MINUTES) * 60 * 1000;
          const elapsed = now - sessionStart;
          const currentPomodoroIndex = Math.floor(elapsed / totalDuration);

          if (currentPomodoroIndex >= session.pomodoros) continue;

          const pomodoroStart = new Date(sessionStart.getTime() + currentPomodoroIndex * totalDuration);
          const timeInPomodoro = now - pomodoroStart;
          const pomodoroNumber = currentPomodoroIndex + 1;

          // å·¥ä½œæ—¶é—´
          if (timeInPomodoro < CONFIG.WORK_MINUTES * 60 * 1000) {
            const secondsInWork = Math.floor(timeInPomodoro / 1000);
            return {
              type: 'work',
              session: session.name,
              pomodoroNumber,
              totalPomodoros: session.pomodoros,
              minutesLeft: CONFIG.WORK_MINUTES - 1 - Math.floor(secondsInWork / 60),
              secondsLeft: 59 - (secondsInWork % 60),
              secondsInWork,
              message: `${session.name.replace('ç•ªèŒ„ç»„', '')}ç¬¬${pomodoroNumber}ä¸ªç•ªèŒ„é’Ÿ - å·¥ä½œä¸­`
            };
          }

          // ä¼‘æ¯æ—¶é—´ï¼ˆæœ€åä¸€ä¸ªç•ªèŒ„åæ— ä¼‘æ¯ï¼‰
          if (currentPomodoroIndex >= session.pomodoros - 1) continue;

          const secondsInRest = Math.floor((timeInPomodoro - CONFIG.WORK_MINUTES * 60 * 1000) / 1000);
          const totalRestSeconds = CONFIG.REST_MINUTES * 60;
          const secondsLeft = totalRestSeconds - secondsInRest;

          return {
            type: 'rest',
            session: session.name,
            pomodoroNumber,
            totalPomodoros: session.pomodoros,
            minutesLeft: Math.floor(secondsLeft / 60),
            secondsLeft: secondsLeft % 60,
            secondsInRest,
            restMinute: Math.floor(secondsInRest / 60),
            message: `ä¼‘æ¯æ—¶é—´ - ${session.name.replace('ç•ªèŒ„ç»„', '')}ç¬¬${pomodoroNumber}ä¸ªç•ªèŒ„é’Ÿå`
          };
        }
      }

      return { type: 'idle', message: 'å½“å‰ä¸åœ¨å·¥ä½œæ—¶é—´æ®µå†…' };
    }

    function getExpectedCompletedPomodoros() {
      const now = new Date();
      const completed = [];
      let pomodoroIndex = 0;
      let currentPomodoro = -1;

      for (const session of SESSIONS) {
        const sessionStart = parseTime(session.start);
        const sessionEnd = parseTime(session.end);

        if (now < sessionStart) break;

        if (now >= sessionEnd) {
          for (let i = 0; i < session.pomodoros; i++) {
            completed.push(pomodoroIndex + i);
          }
          pomodoroIndex += session.pomodoros;
        } else {
          const totalDuration = (CONFIG.WORK_MINUTES + CONFIG.REST_MINUTES) * 60 * 1000;
          const elapsed = now - sessionStart;
          const currentPomodoroInSession = Math.floor(elapsed / totalDuration);

          for (let i = 0; i < currentPomodoroInSession; i++) {
            completed.push(pomodoroIndex + i);
          }

          const timeInPomodoro = elapsed - (currentPomodoroInSession * totalDuration);
          if (timeInPomodoro >= CONFIG.WORK_MINUTES * 60 * 1000 && currentPomodoroInSession < session.pomodoros) {
            completed.push(pomodoroIndex + currentPomodoroInSession);
          } else if (currentPomodoroInSession < session.pomodoros) {
            currentPomodoro = pomodoroIndex + currentPomodoroInSession;
          }

          break;
        }
      }

      return { completed, currentPomodoro };
    }

    // ==================== æé†’ç³»ç»Ÿ ====================
    async function triggerAlerts(status) {
      if (!state.audioEnabled) return;

      let alertKey = '';
      let beeps = null;
      let notificationTitle = '';
      let notificationBody = '';

      if (status.type === 'work') {
        const sec = status.secondsInWork;
        alertKey = `work-${status.pomodoroNumber}-${sec}`;

        const workAlerts = {
          0: { beeps: [{ frequency: 262, duration: 600, count: 8, interval: 150 }], title: 'ğŸ… å¼€å§‹å·¥ä½œ', body: `${status.session.replace('ç•ªèŒ„ç»„', '')}ç¬¬${status.pomodoroNumber}ä¸ªç•ªèŒ„é’Ÿå¼€å§‹äº†ï¼` },
          120: { beeps: [{ frequency: 196, duration: 1200, count: 1 }], title: 'â° 2åˆ†é’Ÿæé†’', body: 'å·²å·¥ä½œ2åˆ†é’Ÿ' },
          750: { beeps: [{ frequency: 196, duration: 1200, count: 2, interval: 200 }], title: 'â° 12.5åˆ†é’Ÿæé†’', body: 'å½“å‰ç•ªèŒ„é’Ÿå·²è¿›è¡Œåˆ°ä¸€åŠ' },
          1380: { beeps: [{ frequency: 196, duration: 1200, count: 3, interval: 200 }], title: 'â° 23åˆ†é’Ÿæé†’', body: 'è¿˜æœ‰2åˆ†é’Ÿç»“æŸå·¥ä½œ' },
          1499: { beeps: [{ frequency: 196, duration: 600, count: 8, interval: 150 }], title: 'âœ… å·¥ä½œç»“æŸ', body: `${status.session.replace('ç•ªèŒ„ç»„', '')}ç¬¬${status.pomodoroNumber}ä¸ªç•ªèŒ„é’Ÿå®Œæˆï¼` }
        };

        if (workAlerts[sec]) {
          beeps = workAlerts[sec].beeps;
          notificationTitle = workAlerts[sec].title;
          notificationBody = workAlerts[sec].body;
        }
      } else if (status.type === 'rest') {
        const minute = status.restMinute;
        if (minute >= 1 && minute <= 4) {
          alertKey = `rest-${status.pomodoroNumber}-${minute}`;
          beeps = [{ frequency: 262, duration: 1200, count: minute, interval: 200 }];
          notificationTitle = `â˜• ä¼‘æ¯${minute}åˆ†é’Ÿ`;
          notificationBody = `ä¼‘æ¯æ—¶é—´å·²è¿‡${minute}åˆ†é’Ÿ`;
        }
      } else if (status.type === 'prep') {
        const minutesLeft = Math.ceil(status.timeLeft / 60000);
        if (minutesLeft === 10) {
          alertKey = 'prep-10';
          beeps = [
            { frequency: 262, duration: 500, count: 1 },
            { frequency: 330, duration: 500, count: 1 },
            { frequency: 294, duration: 500, count: 1 },
            { frequency: 196, duration: 1500, count: 1 }
          ];
          notificationTitle = 'â° å‡†å¤‡å¼€å§‹';
          notificationBody = `${status.session}å°†åœ¨10åˆ†é’Ÿåå¼€å§‹`;
        }
      }

      if (alertKey && alertKey !== state.lastAlertKey) {
        state.lastAlertKey = alertKey;
        if (beeps) {
          await playBeepSequence(beeps);
          // é‡è¦æé†’ï¼ˆå¼€å§‹ã€ç»“æŸï¼‰ä¿æŒæ˜¾ç¤ºç›´åˆ°ç”¨æˆ·äº¤äº’
          const isImportant = alertKey.includes('work-0') || alertKey.includes('work-1499') || alertKey.includes('prep-10');
          if (notificationTitle && document.visibilityState !== 'visible') {
            showNotification(notificationTitle, notificationBody, alertKey, isImportant);
          }
        }
      }
    }

    // ==================== UI æ¸²æŸ“ ====================
    function renderSchedule() {
      const c = document.getElementById('schedule-container');
      SESSIONS.forEach(s => {
        const d = document.createElement('div');
        d.className = 'bg-gray-50 rounded-lg p-4';
        d.innerHTML = `<div class="flex justify-between items-center"><div><div class="font-semibold text-gray-800">${s.name}</div><div class="text-sm text-gray-600">${s.start} - ${s.end}</div></div><div class="text-sm text-gray-600">${s.pomodoros} ä¸ªç•ªèŒ„é’Ÿ</div></div>`;
        c.appendChild(d);
      });
    }

    function renderProgress(elId, start, count, completed, current) {
      const c = document.getElementById(elId);
      c.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const idx = start + i;
        const d = document.createElement('div');
        d.className = 'flex-1 h-6 rounded-lg ' + (completed.includes(idx) ? 'bg-blue-200' : current === idx ? 'bg-blue-50 border-2 border-blue-200' : 'bg-blue-50');
        c.appendChild(d);
      }
    }

    const updateTimerDisplay = (s) => {
      const el = document.getElementById('timer-display');
      if (s.type === 'work') {
        const segs = [{start:0,end:120},{start:120,end:750},{start:750,end:1380},{start:1380,end:1500}];
        el.innerHTML = `<div class="text-6xl font-mono font-bold mb-2">${formatTime(s.minutesLeft,s.secondsLeft)}</div><div class="text-sm opacity-90 mb-4">å·¥ä½œæ—¶é—´</div><div class="flex gap-1 w-full">${renderSegmentBar(segs,s.secondsInWork,{totalSeconds:1500,borderColor:'border-blue-200',fillColor:'#bfdbfe'})}</div>`;
      } else if (s.type === 'rest') {
        const segs = [{start:0,end:60},{start:60,end:120},{start:120,end:180},{start:180,end:240},{start:240,end:300}];
        el.innerHTML = `<div class="text-6xl font-mono font-bold mb-2">${formatTime(s.minutesLeft,s.secondsLeft)}</div><div class="text-sm opacity-90 mb-4">ä¼‘æ¯æ—¶é—´</div><div class="flex gap-1 w-full">${renderSegmentBar(segs,s.secondsInRest,{borderColor:'border-sky-100',fillColor:'#e0f2fe',equalWidth:true})}</div>`;
      } else if (s.type === 'idle') {
        el.innerHTML = `<div class="text-lg opacity-90">å½“å‰æ—¶é—´ï¼š${new Date().toLocaleTimeString('zh-CN')}</div>`;
      } else {
        el.innerHTML = '';
      }
    };

    function updateStatusDisplay(status) {
      const statusDisplay = document.getElementById('status-display');
      const statusIcon = document.getElementById('status-icon');
      const statusMessage = document.getElementById('status-message');

      const styles = {
        work: 'bg-gradient-to-r from-blue-300 to-blue-400',
        rest: 'bg-gradient-to-r from-sky-200 to-blue-200',
        idle: 'bg-gradient-to-r from-slate-300 to-slate-400',
        prep: 'bg-gradient-to-r from-slate-300 to-slate-400'
      };
      const iconPath = 'stroke-linecap="round" stroke-linejoin="round" stroke-width="2"';
      const icons = {
        work: `<path ${iconPath} d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>`,
        rest: `<path ${iconPath} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>`,
        idle: `<path ${iconPath} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>`,
        prep: `<path ${iconPath} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>`
      };

      statusDisplay.className = `rounded-xl p-6 text-white mb-6 ${styles[status.type] || styles.idle}`;
      statusIcon.innerHTML = icons[status.type] || icons.idle;
      statusMessage.textContent = status.message;
    }

    function updateUI() {
      const s = getCurrentStatus();
      const { completed, currentPomodoro: cur } = getExpectedCompletedPomodoros();
      updateStatusDisplay(s);
      updateTimerDisplay(s);
      document.getElementById('progress-text').textContent = `${completed.length} / 10 ä¸ªç•ªèŒ„é’Ÿ`;
      renderProgress('morning-progress', 0, 4, completed, cur);
      renderProgress('afternoon-progress', 4, 4, completed, cur);
      renderProgress('evening-progress', 8, 2, completed, cur);
      triggerAlerts(s);
    }

    // Web Worker è®¡æ—¶å™¨
    const workerCode = `
      let last = Date.now(), id;
      function tick() {
        const now = Date.now();
        const drift = now - last - 1000;
        last = now;
        self.postMessage({type:'TICK'});
        id = setTimeout(tick, Math.max(50, 1000 - drift));
      }
      self.onmessage = e => { if(e.data==='START'){ last=Date.now(); if(id)clearTimeout(id); tick(); } };
    `;
    const worker = new Worker(URL.createObjectURL(new Blob([workerCode])));
    worker.onmessage = e => { if(e.data.type==='TICK') updateUI(); };

    // PWA åŠŸèƒ½
    let deferredPrompt;
    const installBtn = document.getElementById('install-btn-inline');

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js').catch(() => {});
    }

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn?.classList.remove('hidden');
    });

    installBtn?.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === 'accepted') installBtn.classList.add('hidden');
      deferredPrompt = null;
    });

    window.addEventListener('appinstalled', () => {
      deferredPrompt = null;
      installBtn?.classList.add('hidden');
    });

    // å¯åŠ¨
    document.getElementById('enable-audio-btn').addEventListener('click', async () => {
      await enableAudio();
      worker.postMessage('START');
    });
    renderSchedule();
    updateUI();
  </script>
</body>
</html>
